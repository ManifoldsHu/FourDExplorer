# -*- coding utf-8 -*-

"""
*------------------------------- HDFManager.py -------------------------------*
对 HDF5 文件进行读取与写入的操作。

4dExplorer 软件默认使用 HDF5 进行四维数据及其元数据的管理。对于其他格式的文件，例如由
EMPAD 所产生的数据，4dExplorer 将其转换为hdf5进行管理并生成临时文件，用户可自行决定是
否要保存该临时文件为 HDF5 数据集。出于对内存空间资源节约的考虑，所有有关四维数据的计算
都是基于硬盘 IO 的，而在代码层面上不会将数据一次性全部读入内存中(尽管操作系统会尝试这样
做，但即使是内存空间不足，也无需担心会对性能造成影响。)

这样，对于由仪器采集而来的数据，使用 4dExplorer 软件进行数据读取的步骤就是：
    - 在某个文件夹内创建临时 HDF5 数据文件，该文件的主要部分是原四维数据的副本；
    - 根据 HDF5 的特性进行内存映射；
    - 校正与分析，结果都将存储于 HDF5 文件中；
    - 输出分析结果；
    - 保存或删除 HDF5 文件。

在这样的工作流程中，将四维数据复制一份的时间代价较大。为节约后续分析的时间，可以保存 HDF5 
文件，后续重新打开该数据集时可直接建立内存映射，省下加载四维数据的时间开销。在后续打开时，
就将直接调用 HDFManager.py 中的代码。


作者：          胡一鸣
创建时间：      2021年8月21日

Basic operation of HDF5 files.

By default, the 4dExplorer software uses HDF5 to manage 4d data and metadata. 
For other files, such as the data generated by EMPAD, 4dExplorer converts them 
to HDF5 for management and generates temporary files. Users can decide whether 
to save the temporary files as HDF5 data sets or not. In order to save memory 
resources, all computation of the four-dimensional data is based on disk IO, a-
nd the data is not read into memory all at once at the code level (although the 
operating system will try to do this, there is no need to worry about the perf-
ormance impact of running out of memory).

In this way, for the data collected by the specific instrument, the steps of u-
sing 4dExplorer software to read the data are as follows:
    - Create a temporary HDF5 data file in some folder, the main part of which 
    is a copy of the original 4-dimensional data;
    - Memory mapping based on HDF5 features;
    - Calibration and analysis, the results will be stored in the HDF5 file;
    - Output the analysis result;
    - save or delete the HDF5 file.

In such a workflow, the time cost of making a copy of the four-dimensional data 
is large. In order to save the time of subsequent analysis, the HDF5 file can 
be saved, and the memory mapping can be directly established when the data set 
is reopened, saving the time cost of loading the four-dimensional data. On sub-
sequent opens, the code in HDFManager.py is called directly.

author:             Hu Yiming
date:               Aug 21, 2021

All rights reserved.

*------------------------------- HDFManager.py -------------------------------*
"""

# import sys
import os
from datetime import datetime
import re
import threading
import traceback
from collections.abc import Mapping
from typing import Iterator
from logging import Logger

import h5py
import numpy as np

from PySide6.QtCore import (
    QAbstractItemModel, 
    QModelIndex, 
    Qt, 
    Signal, 
    QObject, 
    QAbstractTableModel,
    # QSize,
)
# from PySide6.QtGui import QIcon


# from PySide6.QtWidgets import QApplication 

# from bin.Log import LogUtil

from Constants import APP_VERSION, ItemDataRoles, HDFType
from bin.TaskManager import Task, TaskManager
# from ui.resources import icon_rc


# from bin import DataReaderEMPAD
# from bin.BackEnd import BackEnd
# from bin.Preview import PreviewHandler

# log_util = LogUtil(__name__)
# logger = log_util.logger 
reValidHDFName = re.compile(
    r'[0-9a-zA-Z\_\-\.][0-9a-zA-Z\_\-\.\s]*$'
)   # A valid hdf_name must be able to match this regular expression.

class HDFHandler(QObject):
    """
    使用 HDF5 文件处理的封装类。其应当包含以下方法：

        - 设置指向的 h5 文件的路径
        - 创建 h5 文件并初始化
        - 读取 h5 文件，对不合规的文件进行初始化
        - 删除 h5 文件            # 安全性问题？

        - 生成 HDFTree，用于对 HDF5 文件内部的路径进行管理
        - 根据 HDFTree 生成用于 Qt 的 Model。
        - 根据 hdf_path 取到对应的 HDFTree 中的 HDFTreeNode
        - 根据 hdf_path 取到对应的 HDFTree 中的 HDFTreeNode 在同级 Node 中的序号
        - 根据 hdf_path 增加 Group，同时修改对应的 HDFTree
        - 根据 hdf_path 增加 Data，同时修改对应的 HDFTree
        - 根据 hdf_path 删除 Group 或 Data，同时修改对应的 HDFTree
        - 根据 hdf_path 移动 Group 或 Data，同时修改对应的 HDFTree
        - 根据 hdf_path 重命名 Group 或 Data，同时修改对应的 HDFTree
        - 根据 hdf_path 复制 Group 或 Data，同时修改对应的 HDFTree。这个过程很耗时，
            所以打包成一个 Task，并且提交给 TaskManager。

    可以为 Dataset 类指定扩展名，就像平时在 UNIX 或 Windows 操作系统中指定扩展名那
    样子。扩展名不是必需的，但如果有扩展名可以帮助 4D-Explorer 更好地识别这些 Dataset
    的类型。目前支持的数据集的类型及对应的扩展名如下：
        FourDSTEM       4d
        Line            line
        Image           img
        VectorField     vec
    尽管我不认为有这个必要，但后续如果想要极致的可扩展性的话，可以考虑将类型系统也做得
    和操作系统一样，使用一张表来确定类型，而不是写入代码里。


    注意，这个类使用单例模式。在程序的任何地方要想取到这个实例，要先取到全局变量 qApp, 
    然后得到 qApp.hdf_handler 即可。

    初始化完成的h5文件应当有如下结构：
        /Dataset                            四维数据集。

        /Calibration                        作为 Group ，其 Attribution 内有各种
                                            校正操作类。

        /Reconstruction                     作为Group，储存每一次的计算结果。

        /Reconstruction/1_iCoM/Matrix       某一次重构的计算结果，作为二维矩阵。其
                                            Attribute 包含了数据类型、计算类型、计
                                            算参数、计算时所使用的 Calibration 配
                                            置。“1_iCoM” 指的是计算任务名字，其为 
                                            “数字-算法” 的结构。

        /Reconstruction/1_iCoM/1_imshow     作为 Group，其 Attribution 保存的是封
                                            装的画图类，储存了对这次重构得到的结果
                                            进行画图所使用的参数。

        /tmp                                临时数据，用来保存当 Calibration 不变
                                            时，上一次计算得到的 CoM 矢量，及其他未
                                            来可能出现的中间结果。关闭时应当删除该 
                                            Group 下所有数据。


          
    This is the encapsulated classes that use HDF5 file processing. It should 
    contain the following methods:    
        - set the path of the h5 file,
        - create the h5 file and initialize,
        - read the h5 file, and initialize those invalid files,
        - delete the h5 file (will be used to delete temp files),

        - create HDFTree, in order to manage the hdf path,
        - according to the HDFTree, create model for Qt (Model-View structure),
        - according to the hdf_path, get Node in the HDFTree,
        - according to the hdf_path, get row of the node in the HDFTree,
        - according to the hdf_path, create group and fix HDFTree,
        - according to the hdf_path, create data and fix HDFTree,
        - according to the hdf_path, remove items and fix HDFTree,
        - according to the hdf_path, move items and fix HDFTree,
        - according to the hdf_path, rename items and fix HDFTree,
        - according to the hdf_path, copy items and fix HDFTree. NOTE: copying
            is time-consumed and comprehensive, so we pack the copy operation
            into a Task, and submit it to the Task Manager.


    For those Dataset object in HDF5 file, we can give them an extension name,
    just like the UNIX/Windows operation system, so 4D-Explorer will recognize
    them and set appropriate HDFType to the node in the HDFTree. For now, we 
    support these type of Dataset and corresponding extension names:
        FourDSTEM       4d
        Line            line
        Image           img
        VectorField     vec
    Although I don't think it's necessary, but if we want more extendibility, 
    we can register these types as a table in a file rather than write them in
    the python code.


    NOTE: there is only SINGLE instance. Anywhere we need to get the pointer of
    this instance, use the global pointer qApp, and get qApp.hdf_handler. 

    An initialized h5 file should have the following structure:

    /Dataset                                Four-dimensional data set.

    /Calibration                            As a group, there are various cali-
                                            bration classes inside its attribu-
                                            tion.

    /Reconstruction                         As a group, each calculation are s-
                                            aved here.

    /Reconstruction/1_iCoM/Matrix           The result of a reconstruction, as 
                                            a two-dimensional matrix. Attribute 
                                            contains the data type, calculation 
                                            type, calculation parameters, and 
                                            the Calibration configuration used 
                                            in the calculation.  "1_iCoM" is t-
                                            he name of the calculation task, w-
                                            hich is a "number-algorithm" struc-
                                            ture.  

    /Reconstruction/1_iCoM/1_imshow.img     As a Group, its attribution preser-
                                            ves the encapsulated drawing class 
                                            that stores the parameters to use 
                                            to draw the results of the matrix. 

    /tmp                                    Temporary group, used to store the 
                                            CoM vector from the last calculati-
                                            on when the Calibration is unchang-
                                            ed, as well as other intermediate 
                                            results that may occur in the futu-
                                            re. When closing, all data in this 
                                            Group should be deleted.



    Attributes:
        file_path: (str) the HDF5 file path.
        file: (h5py.File) the OPENED HDF5 file, or NoneType.
        model: (HDFTreeModel) get the model of the file tree.

    Signals:
        file_state_changed: When file is opened or closed, this signal emits.
    """

    file_about_to_close = Signal()
    file_closed = Signal()
    file_opened = Signal()
    model_created = Signal()

    def __init__(self, parent: QObject = None):
        super().__init__(parent)
        self._file = None
        self._file_path = ''
        self._lock = threading.Lock()   # read/write lock
        self._root_node = HDFRootNode()
        self._createModel()
        self._keep_file_opened = []

        global qApp
        self.file_closed.connect(qApp.clearMetaManagerDict)
    
    @property
    def logger(self) -> Logger:
        global qApp
        return qApp.logger

    @property
    def file_path(self):
        """
        Get the current h5 file path.

        returns:
            (str) the current h5 file path. If there is no file opened,
                returns ''.
        """
        return self._file_path

    @file_path.setter
    def file_path(self, value: str):
        """
        Set the h5 file path. 
        
        NOTE: Will close the current file, and change the current working 
        directory.

        arguments:
            value: (str) the absolute path of the new h5 file.

        """
        if not isinstance(value, str):
            raise TypeError('Expected a string.')
        if value != self.file_path and self.isFileOpened():
            self.file.close()

        os.chdir(os.path.dirname(value))
        self._file_path = value
        self.logger.debug('Set HDF file path to: {0}'.format(value))

    def isFilePathValid(self) -> bool:
        """
        Return whether the file is a valid h5 file.

        returns:
            (bool)
        """
        try:
            with h5py.File(self.file_path, mode = 'r') as file:
                is_valid = isinstance(file, h5py.File)
            return is_valid
        except OSError as e:
            self.logger.error('{0}'.format(e), exc_info = True)
            return False
          
     
    @property
    def file(self) -> h5py.File:
        """
        Returns opened file. if the file is not opened, returns NoneType.

        Returns:
            (h5py.File)
        """
        if self.isFileOpened():
            return self._file
        else:
            return None

    @file.setter
    def file(self, h5_file: h5py.File):
        """
        Set the h5 file.

        arguments:
            h5_file: (h5py.File) Must be h5py.File or NoneType.
        """
        if h5_file is None or isinstance(h5_file, h5py.File):
            self._file = h5_file
        else:
            raise TypeError('file must be a h5py.File or None.')

    @property
    def model(self):
        """
        Get the Internal HDFTreeModel.
        """
        return self._model

    def createFile(self) -> bool:
        """
        Create a new standard h5 file according to the file_path attribute.
        
        Fail if there exists.

        returns:
            (bool) whether the file is created.
        """
        try:
            with h5py.File(self.file_path, mode = 'w') as file: 
                # create, truncate if exists
                self._initializeFile(file)
        except OSError as e:
            self.logger.error('{0}'.format(e), exc_info = True)
            return False
        self.logger.debug('Create file: {0}'.format(self.file_path))
        return True


    def _initializeFile(self, file: h5py.File):
        """
        Initialize a h5 file. Some groups and attributes will be added.

        arguments:
            file: (h5py.File) the file object being initialized.
        """
                    
        if 'Reconstruction' not in file:
            file.create_group('Reconstruction')
        if 'Calibration' not in file:
            file.create_group('Calibration')
        if 'tmp' not in file:
            file.create_group('tmp')

        root = file['/']
        root.attrs['4D-Explorer'] = True
        root.attrs['FileCreateTime'] = '{0}'.format(datetime.now())
        root.attrs['Version'] = str(APP_VERSION)
        
        self.logger.debug('Initialize file')
    

    def openFile(self):
        """
        Open a h5 file. 
        
        Fail if there is no file corresponding to the file_path attribute. 
        The file must be opened before it is handled by HDFManager modules.

        Returns:
            (h5py.File) the opened file.
        """
        try:
            if not self.isFileOpened():
                # Read/write, file must exist
                self.file = h5py.File(self.file_path, mode='r+')
                self.buildHDFTree()
                self.file_opened.emit()
                
        except OSError as e:
            self.logger.error('{0}'.format(e), exc_info = True)
            return None
        self.logger.info('Open file: {0}'.format(self.file_path))
        return self.file

    def registerKeepFileOpen(self) -> int:
        """
        This function will keep a list to ask whether other objects need to 
        keep the file opened. (They may collapse if the file is suddenly 
        closed.) 

        The returned int is the id of the variable that indicates whether the
        file can be closed. Only when all of the variables are False, the file
        can be closed.

        The object that call this function should keep the returned id. Also, 
        they should connect hdf_handler.file_about_to_close signal to their 
        some functions to estimate if it is suitable to close the file. If it 
        is not suitable, that function should call hdf_handler.holdFile() to 
        let the hdf_handler know.
        """
        index = len(self._keep_file_opened)
        self._keep_file_opened.append(False)
        return index 

    def holdFile(self, index: int):
        """
        When hdf_handler.file_about_to_close signal emits, there is a chance 
        for some object to call this function. It can prevent to close the 
        current HDF5 file.

        arguments:
            index: (int)
        """
        self._keep_file_opened[index] = True 


    def closeFile(self):
        """
        Try to close the h5 file. 
        
        The file must be closed before:
            - the file_path is changed
            - the file is deleted
            - the application is exit

        When the file is about to close, self.file_about_to_close is emitted to 
        inform other objects. Before that, hdf_handler._keep_file_opened list 
        will be set to all False, and wait for the answers from the registered 
        objects. If some object want to keep the file opened, it can call the 
        function hdf_handler.holdFile() to modify the list. After that, if this
        function find that all of the items in the list is False, it will close 
        the file. 
        """
        if self.isFileOpened():
            self.file_about_to_close.emit()     
            # When file is about to close, this signal is emitted to inform 
            # Tabview Manager and Task Manager. 
            for is_file_held in self._keep_file_opened:
                if is_file_held:
                    return False 
            
            self.file.close()
            self.file_closed.emit()
            self.logger.info('Close file: {0}'.format(self.file_path))
        self.file = None
          

    def isFileOpened(self) -> bool:
        """
        Returns whether the hdf5 file is opened.

        returns:
            (bool) 
        """
        if self._file is None:
            return False
        elif not self._file.id: 
            # It seems in h5py they use this to estimate if the file is closed.   
            return False
        else:
            return True


    def deleteFile(self) -> bool:
        """
        Delete the h5 file. Fail if there is no file.

        returns:
            (bool)
        """
        if self.isFileOpened():
            self.file.close()
        if self.isFilePathValid():
            try:
                os.remove(self.file_path)
                self.logger.debug('Delete file: {0}'.format(self.file_path))
                return True
            except OSError as e:
                self.logger.error('{0}'.format(e), exc_info = True)
                return False


    def _createModel(self):
        """
        Create a HDFTreeModel for Qt Views.

        returns:
            (HDFTreeModel) the model of hierarchical structure of the current
                HDF5 file. 
        """
        self._model = HDFTreeModel(self)
        self.model_created.emit()
        

    @property
    def root_node(self) -> 'HDFRootNode':
        return self._root_node

    def buildHDFTree(self):
        """
        Build an HDFTree according to the current HDF5 file.

        Will add child nodes recursively for the root_node and its childs.
        """
        if self.isFileOpened():
            self._root_node = self.addChildDeepFirst(HDFRootNode())
        else:
            self._root_node = HDFRootNode()
        self._createModel()
            
    def addChildDeepFirst(self, parent: 'HDFGroupNode'):
        """
        Add child nodes recursively for the root_node and its childs.

        Only Group and Dataset object in the HDF5 file will be added.

        TODO: Other types like String, Referece and External Links.

        arguments:
            parent: (HDFGroupNode)

        returns:
            (HDFGroupNode) returns the parent node from the argument, but the
                parent node has been added children.
        """
        if not isinstance(parent, HDFGroupNode):
            raise TypeError('parent must be an HDFGroupNode, not '
                '{0}'.format(type(parent).__name__))
        
        for key in self._file[parent.path]:
            if isinstance(self._file[parent.path][key], h5py.Group):
                parent.addChild(HDFGroupNode(key))
                self.addChildDeepFirst(parent[key])
            elif isinstance(self._file[parent.path][key], h5py.Dataset):
                parent.addChild(HDFDataNode(key))
        return parent

    def getNode(self, hdf_path: str) -> 'HDFTreeNode':
        """
        Get Node with the absolute path of the HDF5 items.

        The path must start with '/', and end with the items' name.

        arguments:
            hdf_path: (str) absolute path of the HDF5 items.

        returns:
            (HDFTreeNode) 
        """
        if not isinstance(hdf_path, str):
            raise TypeError(('hdf_path must be str, not '
                '{0}'.format(type(hdf_path).__name__)))
        elif hdf_path == '':
            raise KeyError('hdf_path can not be null string')
        elif hdf_path[0] != '/':
            raise KeyError('hdf_path must start with slash /')
        elif len(hdf_path) > 1 and hdf_path[-1] == '/':
            raise KeyError('hdf_path cannot end with slash /')
        elif hdf_path == '/':
            return self.root_node
        else:
            keys_array = hdf_path.split('/')[1:]
            node = self.root_node
            for key in keys_array:
                if key in node:
                    node = node[key]
                else:
                    raise KeyError(('There is no key '
                        '{0} in {1}'.format(key, node.name)))
            return node

    def getRank(self, hdf_path: str = '') -> int:
        """
        Get the rank of the node among its mates.

        In the hash table, the rank is not fixed. Here we will get the rank by 
        the keysview of the dict. It is usually used to show items in a table.

        arguments:
            hdf_path: (str) absolute path of the HDF5 items

        returns:
            (int) rank of the node among its mates.
        """
        if hdf_path == '/':
            return 0
        else:
            # print(hdf_path)
            this = self.getNode(hdf_path)
            key = hdf_path.split('/').pop()
            rank = list(this.parent.keys()).index(key)
            return rank

    def addNewGroup(self, parent_path: str, name: str):
        """
        Add a group in the parent_path.

        Will add a group in the HDF5 file and add a HDFGroupNode in HDFTree.

        arguments:
            parent_path: (str) absolute path of the HDF5 group.

            name: (str) name of the new group
        """
        if not isinstance(parent_path, str):
            raise TypeError(('parent_path must be str, not '
                '{0}'.format(type(parent_path).__name__)))
        elif not isinstance(name, str):
            raise TypeError(('name must be str, not '
                '{0}'.format(type(name).__name__)))
        parent_node = self.getNode(parent_path)
        if name in parent_node:
            raise ValueError(('name {0} exists in {1}\n'
                'path: {2}'.format(name, parent_node.name, parent_path)))

        self.file[parent_path].create_group(name)

        parent_model_index = self.model.indexFromPath(parent_path)
        row = len(parent_node)
        self.model.beginInsertRows(parent_model_index, row, row)
        parent_node.addChild(HDFGroupNode(name))
        self.model.endInsertRows()

        self.logger.debug('Create group {0} in {1}'.format(name, parent_path))
        

    def addNewData(self, 
        parent_path: str, 
        name: str, 
        shape: tuple, 
        dtype: str = 'float32',
        compression: str = None,
        # compression: str = 'gzip', # compression has some performance problem
    ):
        """
        Create a dataset in the parent_path.

        Will add a dataset in the HDF5 file and add a HDFDataNode in HDFTree.

        arguments:
            parent_path: (str) absolute path of the HDF5 group

            name: (str) name of the new dataset
        """
        if not isinstance(parent_path, str):
            raise TypeError(('parent_path must be str, not '
                '{0}'.format(type(parent_path).__name__)))
        elif not isinstance(name, str):
            raise TypeError(('name must be str, not '
                '{0}'.format(type(name).__name__)))
        parent_node = self.getNode(parent_path)
        if name in parent_node:
            raise ValueError(('name {0} exists in {1}\n'
                'path: {2}'.format(name, parent_node.name, parent_path)))

        if shape == ():
            self.file[parent_path].create_dataset(
                name,
                shape = shape,
                dtype = dtype,  
                # scalar does not have compression property
            )
        else:
            self.file[parent_path].create_dataset(
                name, 
                shape = shape, 
                dtype = dtype, 
                compression = compression,
            )

        parent_model_index = self.model.indexFromPath(parent_path)
        row = len(parent_node)
        self.model.beginInsertRows(parent_model_index, row, row)
        parent_node.addChild(HDFDataNode(name, parent_node))
        self.model.endInsertRows()
        
        self.logger.debug('Create data {0} in {1}'.format(name, parent_path))

    def deleteItem(self, item_path: str):
        """
        Delete the item with the item_path.

        Will delete the item in the practical HDF5 file, and delete the node in 
        HDFTree. If the item is a group, and there are subitems in the item, 
        all of the subitems will be removed recursively.

        arguments:
            item_path: (str) absolute path of hdf5 item.
        """
        if not isinstance(item_path, str):
            raise TypeError(('hdf_path must be a str, not '
                '{0}'.format(type(item_path).__name__)))
        elif item_path == '/':
            raise ValueError('Cannot delete root')

        del self.file[item_path]

        this_node = self.getNode(item_path)
        parent_node = this_node.parent
        parent_model_index = self.model.indexFromPath(parent_node.path)
        row = self.getRank(item_path)

        self.model.beginRemoveRows(parent_model_index, row, row)
        parent_node.deleteChild(this_node)
        self.model.endRemoveRows()
        
        self.logger.debug('Delete {0}'.format(item_path))

    def moveItem(self, item_path: str, dest_parent_path: str):
        """
        Move item from item_path to dest_parent_path. 
        
        The destination parent path must indicate a group. The item's name will 
        not change.

        There are some operation forbidden:
            - Cannot move an item to its current parent group
            - Cannot move a group to its subgroup
            - Cannot move an item to a dataset's path
            - Cannot move an item to a non-exist path.

        arguments:
            item_path: (str) the item's path to be moved

            dest_parent_path: (str) the destination group's path
        """
        if not isinstance(item_path, str):
            raise TypeError(('item_path must be a str, not '
                '{0}'.format(type(item_path).__name__)))
        elif not isinstance(dest_parent_path, str):
            raise TypeError(('dest_parent_path must be a str, not '
                '{0}'.format(type(dest_parent_path).__name__)))

        this_node = self.getNode(item_path)
        this_parent_node = this_node.parent
        dest_parent_node = self.getNode(dest_parent_path)

        if isinstance(this_node, HDFRootNode):
            raise ValueError('Cannot move root')

        elif not isinstance(dest_parent_node, HDFGroupNode):
            raise ValueError(('Destination path must be a group: '
                '{0}'.format(dest_parent_path)))

        elif dest_parent_node is this_parent_node:
            raise ValueError('The destination is the same as current path')

        elif dest_parent_node is this_node:
            raise ValueError('The destination cannot be this group itself')

        elif dest_parent_node.isSubNode(this_node):
            self.logger.debug(dest_parent_node.path)
            self.logger.debug(this_node.path)
            raise ValueError(('The destination: {0}\n'
                'cannot be subgroup of current group: '
                '{1}'.format(dest_parent_path, this_node.path)))

        elif this_node.name in dest_parent_node:
            raise ValueError(('Name {0} exists in destination: '
                '{1}'.format(this_node.name, dest_parent_path)))
        
        if isinstance(dest_parent_node, HDFRootNode):
            dest_path = '/' + this_node.name
        else:
            dest_path = dest_parent_path + '/' + this_node.name
        
        self.file.move(item_path, dest_path)

        this_parent_model_index = self.model.indexFromPath(
            this_parent_node.path
        )
        this_row = self.getRank(item_path)
        dest_parent_model_index = self.model.indexFromPath(dest_parent_path)
        dest_row = len(dest_parent_node)
        self.model.beginMoveRows(
            this_parent_model_index,
            this_row,
            this_row,
            dest_parent_model_index,
            dest_row,
        )
        this_parent_node.deleteChild(this_node)
        dest_parent_node.addChild(this_node)
        self.model.endMoveRows()

        self.logger.debug('Move {0} to {1}'.format(
            item_path, dest_parent_path))
        
    def renameItem(self, item_path: str, new_name: str):
        """
        Rename item from the current name to a new name.
        
        arguments:
            hdf_path: (str) the item's path to be renamed

            new_name: (str) the new name
        """
        if item_path == '/':
            raise ValueError('Cannot rename root')
        item_node = self.getNode(item_path)
        parent_node = item_node.parent
        if new_name == item_node.name:
            raise ValueError('The name is not changed')
        elif new_name in parent_node:
            raise ValueError('New name exists in current group')
        if isinstance(parent_node, HDFRootNode):
            new_path = '/' + new_name
        else:
            new_path = item_node.parent.path + '/' + new_name

        
        self.file.move(item_path, new_path)

        # We first remove the child node, then modify the name, and last add 
        # the child node back to the current parent node.
        
        # Due to the complicate implication of rename operation, I can only
        # use this method. I have no idea how to do it elegantly, with top-
        # down approach. It seems that the rename operation can not be regarded
        # as one 'atomic' operation, but must do it step by step. 

        # Maybe a better approach is to rebuild the whole model... Here I
        # guess there is methods to rebuild the indices under one parent index
        # of QAbstractItemModel, but I have no idea how to do it.
        parent_index = self.model.indexFromPath(parent_node.path)
        self.model.beginRemoveRows(
            parent_index,
            self.model.indexFromPath(item_path).row(),
            self.model.indexFromPath(item_path).row(),
        )
        parent_node.deleteChild(item_node)
        self.model.endRemoveRows()

        item_node.name = new_name

        self.model.beginInsertRows(
            parent_index,
            self.model.rowCount(parent_index),
            self.model.rowCount(parent_index),
        )
        parent_node.addChild(item_node)
        self.model.endInsertRows()
        
        self.logger.debug('Rename {0} to {1}'.format(item_path, new_name))



    def copyItem(self, item_path: str, dest_parent_path: str):
        """
        Copy item to destination.

        The copied item's name will add '_replica' automatically. Copying large
        dataset is time-consuming, so it should be encapsulated to a Task and 
        submitted to TaskManager.

        arguments:
            item_path: (str) the item's path to be copied

            dest_parent_path: (str) the destination group's path
        """
        if not isinstance(item_path, str):
            raise TypeError(('item_path must be a str, not '
                '{0}'.format(type(item_path).__name__)))
        elif not isinstance(dest_parent_path, str):
            raise TypeError(('dest_parent_path must be a str, not '
                '{0}'.format(type(dest_parent_path).__name__)))
        elif item_path == '/':
            raise ValueError('Cannot copy the whole root.')

        this_node = self.getNode(item_path)
        this_parent_node = this_node.parent
        dest_parent_node = self.getNode(dest_parent_path)

        if not isinstance(dest_parent_node, HDFGroupNode):
            raise ValueError('Destination must be a group')

        if this_parent_node.path == dest_parent_path:
            new_name = self._getNewNameInSameGroup(this_node)
        else:
            if this_node.name in dest_parent_node:
                raise ValueError('Name {0} exists in destination: '
                    '{1}'.format(this_node.name, dest_parent_path))
            else:
                new_name = this_node.name
        
        copy_task = TaskCopy(self, item_path, dest_parent_path, new_name)
        self.logger.debug('Copy task added, from {0} to {1}'.format(
            item_path, dest_parent_path))
        copy_task.addToTaskManager()
        


    def _getNewNameInSameGroup(self, node: 'HDFTreeNode'):
        """
        Get a new name when copying a node inside one group.

        Will conserve extension name, while add _replica to the name.

        attribute:
            node: (HDFTreeNode) the copied node

        returns:
            (str) new name, which will not collide with other items.
        """
        parent = node.parent
        if '.' in node.name:
            old_name, ext = node.name.split('.')
            new_name = old_name + '_replica.' + ext 
            _count = 1
            while new_name in parent:
                new_name = old_name + '_replica_{0}.'.format(_count) + ext
                _count += 1
        else:
            old_name = node.name
            new_name = old_name + '_replica'
            _count = 1
            while new_name in parent:
                new_name = old_name + '_replica_{0}'.format(_count)
                _count += 1
        return new_name
    

    def changeDataType(self, item_path: str, new_type: HDFType):
        """
        Change Data's type into lines, images, vector fields or 4D-STEM datacu-
        bes. Can also change data's type to general data.

        This function will not influence the practical data in H5 file, but to 
        adjust the type of node and available actions of users.

        attributes:
            item_path: (str) the data's type to be changed.
            new_type: (HDFType) new type of data.
        """
        if not isinstance(item_path, str):
            raise TypeError(('item_path must be a str, not '
                '{0}'.format(type(item_path).__name__)))
        elif not isinstance(new_type, HDFType):
            raise TypeError(('new_type must be a member of HDFType, not '
                '{0}',format(type(new_type).__name__)))
        node = self.getNode(item_path)
        if not isinstance(node, HDFDataNode):
            raise RuntimeError('Only hdf_type of Data can be changed.')
        node.hdf_type = new_type

    def matchNodeGenerator(self, kw: str):
        """
        A generator that yields nodes matching the key word.

        arguments:
            kw: (str) the key word to be matched

        returns:
            (generator) generate HDFTreeNode instance
        """
        if not isinstance(kw, str):
            raise TypeError(('kw must be a str, not '
                '{0}'.format(type(kw).__name__)))
        def _matchSubNode(node:'HDFTreeNode'):
            for key in node:
                if kw in key:
                    yield node[key]
                if isinstance(node[key], HDFGroupNode):
                    for subnode in _matchSubNode(node[key]):
                        yield subnode
        return _matchSubNode(self.root_node)



class HDFTreeNode(Mapping):
    """
    HDFTree 路径树的节点。
    
    这是一个基类，要实例化的话，请使用 HDFGroupNode 和 HDFDataNode 这些子类。

    根节点的名字强制为空字符串 ''。除此之外，其他节点的命名规则是：
        - 不能为空字符串
        - 只能包含数字、英文字母、下划线 '_'、短横杠 '-'、点号 '.' 以及空格
        - 不能以空格开头。


    The Node of HDFTree. 
    
    It is not recommended to instantiate HDFTreeNode, but to instantiate its 
    subclass like HDFGroupNode and HDFDataNode. 
    
    
    The name of the root node is forced to be null str '', while other nodes h-
    ave their own names. Except the root node, others' name follow these rules:
        - cannot be a null string
        - can only include numbers, English characters, underline '_', dashline
        '-', dot '.', and space ' '
        - cannot start with space ' '.
    

    attributes:
        name: (str) The name of the node. if the name is null string (''), it 
            is the root node of the HDFTree.

        parent: (HDFTreeNode) The parent node of this node.

        path: (str) The hdf_path of this node. like '/foo/abc' 

        hdf_type: (HDFType) the hdf_type of this node.
    """

    def __init__(self, name: str, parent: 'HDFTreeNode' = None):
        """
        arguments:
            name: (str) only root's name can and must be null string ''. Usual-
                ly, to instantiate a root node, use HDFGroupNode rather than 
                HDFTreeNode. 

            parent: (HDFTreeNode or NoneType)
        """
        self._name = name
        self._parent = parent
        self._mapping = {}
        self._hdf_type = HDFType.Item 
    
    def __getitem__(self, key: str) -> 'HDFTreeNode':
        return self._mapping[key]

    def __iter__(self) -> Iterator:
        return iter(self._mapping)

    def __len__(self) -> int:
        return len(self._mapping)

    def __str__(self) -> str:
        return '<HDFTreeNode> name: {0}'.format(self.name)

    def __repr__(self) -> str:
        return self.__str__()

    @property 
    def name(self) -> str:
        return self._name

    @name.setter
    def name(self, new_name: str):
        """
        Give a new name to this node. The name here must be a string that:
            - can only include numbers, characters, underline '_', dash '-', 
                dot '.' and space ' '.
            - cannot start as space ' '.
        Otherwise a ValueError is raised.

        arguments:
            new_name: (str) give a new name to this node. User must change the
                practical item's name in the HDF file at the same time. Otherw-
                ise, after a flush the name change will be lost.
        """
        if new_name == '':
            self._name = ''
        else:
            # valid_name_pattern = r'^[0-9a-zA-Z\_\-\.][0-9a-zA-Z\_\-\.\s]*$'
            if not isinstance(new_name, str):
                raise TypeError(('new_name must be a str, not '
                    '{0}'.format(type(new_name))))
            elif reValidHDFName.fullmatch(new_name) is None:
                raise ValueError('Invalid name: {0}'.format(new_name))
            elif new_name[-1] == '.':
                raise ValueError('Invalid name: {0}'.format(new_name))
            else:
                self._name = new_name
                
    @property 
    def parent(self):
        return self._parent

    @parent.setter
    def parent(self, parent: 'HDFGroupNode'):
        """
        Set the parent node of this node.

        arguments:
            parent: (HDFTreeNode) either also an HDFTreeNode or NoneType. In 
                most cases, if the parent is None, the node's name should be 
                null string '', which indicates that this is a root node.
        """
        if parent is None:
            self._parent = None
        elif not isinstance(parent, HDFGroupNode):
            raise TypeError('parent must be HDFTreeNode or NoneType,'
                ' not {0}'.format(type(parent)))
        elif parent is self:
            raise ValueError('node parent cannot be itself!')
        else:
            self._parent = parent

    @property 
    def path(self) -> str:
        """
        Indicates the full hdf_path of this node inside the file. Like:
        '/', (root)
        '/foo/abc' (maybe a group or a data)

        returns:
            (str) the full hdf_path of this node.
        """
        if self._path_in_tree == '':
            return '/'
        else:
            return self._path_in_tree

    @property
    def _path_in_tree(self) -> str:
        if self.parent is None or self.name == '':
            return ''
        elif self.parent is None and self.name != '':
            return self.name
        else:
            return self.parent._path_in_tree + '/' + self.name

    def isSubNode(self, node: 'HDFTreeNode') -> bool:
        """
        Returns whether node is the ancestor of this node. 
        
        If node is just this node, returns True.
        If node is root (does not have parent), returns True.

        arguments:
            node: (HDFTreeNode) potential ancestor node

        returns:
            (bool)
        """
        if not isinstance(node, HDFTreeNode):
            raise TypeError(('node must be an HDFTreeNode, not '
                '{0}'.format(type(node).__name__)))
        
        if node is self:
            return True
        ancestor = self
        while not ancestor is None:
            if ancestor is node:
                return True
            ancestor = ancestor.parent
        return False

    @property
    def hdf_type(self) -> HDFType:
        return self._hdf_type
    
    @hdf_type.setter
    def hdf_type(self, new_type: HDFType):
        if not isinstance(new_type, HDFType):
            raise TypeError('New type must be a member of HDFType')
        self._hdf_type = new_type 

class HDFGroupNode(HDFTreeNode):
    """
    用来表示 Group 的节点。

    可以为其添加、删除子节点。为了支持类似于 Mapping 风格 (类似于 dict) 的读取方式，
    我们应当实现以下魔法方法：
        - __contains__(self, key: str) -> bool
        - __getitem__(self, key: str) -> obj
        - __setitem__(self, key: str, child: HDFTreeNode)
        - __iter__(self) -> iterator
        - __len__(self) -> int
        - keys(self) -> KeysView
        - items(self) -> ItemsView
        - values(self) -> ValuesView

    注意，与 h5py 中表现得不同，不能通过 hdf_path 取到其子节点：
        node['/foo/abc']            (No)
        node['foo']                 (Yes)
    此外，对 Node 的子节点进行修改时，不建议直接使用
        node['foo'] = child_node
    的方式，因为这样可能会有如下副作用：
        - 将 child_node 从其 parent 的子节点中删除
        - 将现有的 node['foo'] 的 parent 属性改成 None
        - 将现有的 node['foo'] 从子节点中删除
        - 将 child_node 的 parent 属性改成 node
        - 将 child_node 的 name 属性改成 'foo'
    因此，建议使用 addChild() 和 deleteChild() 方法，并且由用户手动控制这个过程。


    This node is to indicate Groups in HDF5 files. 
    
    We can add or remove its child. In order to support mapping style (like 
    dict in python), we need to reimplement the following methods:
        - __contains__(self, key: str) -> bool
        - __getitem__(self, key: str) -> obj
        - __iter__(self) -> iterator
        - __len__(self) -> int
        - keys(self) -> KeysView
        - items(self) -> ItemsView
        - values(self) -> ValuesView

    NOTE: Unlike mapping interface in h5py, we cannot get subitem from hdf_path
    like this:
        node['/foo/abc']            (No)
        node['foo']                 (Yes)
    Also, when we need to change subnodes, it is NOT recommended to use
        node['foo'] = child_node
    because it may has following side-effect:
        - delete child_node from its parent's subitems
        - change the 'parent' attribute of current node['foo'] to None
        - delete the current node['foo'] from this subitems
        - change the 'parent' attribute of child_node to this
        - change the 'name' attribute of child_node to 'foo'
    Hence, use addChild() and deleteChild() method instead.


    attributes:
        name: (str) only root's name can and must be null string ''. 

        parent: (HDFTreeNode or NoneType)

        hdf_type: (HDFType) must be HDFType.Group
    """

    def __init__(self, name: str = '', parent: 'HDFGroupNode' = None):
        """
        arguments:
            name: [optional](str) only root's name can and must be a null stri-
                ng 
            
        parent: [optional](HDFTreeNode or NoneType) only root's parent can and
        must be NoneType.
        """
        super().__init__(name, parent)
        self._hdf_type = HDFType.Group 


    def __setitem__(self, key: str, child: HDFTreeNode):
        """
        NOTE: this method may have following side-effect:
            - delete the original child from this node, 
            - change the original child's parent attribute to None
            - delete new child from its original parent,
            - change new child's parent attribute to this,
            - change new child's name to the key

        It is not recommended to use this method to set child. Use addChild()
        and deleteChild() methods instead.
        """
        
        if not isinstance(key, str):
            raise TypeError(('Key must be a string, not '
                '{0}'.format(type(key).__name__)))
        if not isinstance(child, HDFTreeNode):
            raise TypeError(('child must be a HDFTreeNode, not '
                '{0}'.format(type(child).__name__)))

        if key == '':
            raise ValueError('Cannot set child name as a null string')
        elif reValidHDFName.fullmatch(key) is None:
            raise ValueError('Invalid child name: {0}'.format(key))

        if key in self._mapping:    # delete original child from this
            original_child = self._mapping[key]
            original_child.parent = None
            del self._mapping[key]

        self._mapping[child.name] = child

        if child.parent:            # delete child from its original parent
            del child.parent[child.name]
        child.name = key
        child.parent = self

    def __delitem__(self, key: str):
        del self._mapping[key]

    def __contains__(self, key: str) -> bool:
        return key in self._mapping
    
    @property
    def hdf_type(self) -> HDFType:
        return HDFType.Group 

    def addChild(self, child: HDFTreeNode):
        """
        Add a child to this node. Will change child's parent attribute.

        arguments:
            child: (HDFTreeNode)
        """
        if not isinstance(child, HDFTreeNode):
            raise TypeError(('child must be a HDFTreeNode, not '
                '{0}'.format(type(child).__name__)))
        if child.name == '':
            raise ValueError('Cannot set child name as a null string')
        if child.name in self:
            raise ValueError(('Child name already exists: '
                '{0}'.format(child.name)))
        else:
            self._mapping[child.name] = child
            child.parent = self

    def deleteChild(self, child: HDFTreeNode) -> HDFTreeNode:
        """
        Delete a child of this node. Will change child's parent attribute.

        arguments:
            child: (HDFTreeNode)

        returns:
            (HDFTreeNode) the deleted child
        """
        if not isinstance(child, HDFTreeNode):
            raise TypeError(('child must be an HDFTreeNode, not '
                '{0}'.format(type(child).__name__)))
        elif not child.name in self:
            raise KeyError(('child name not found in this node: '
                '{0}'.format(child.name)))
        elif child.parent != self:
            raise ValueError('The parent of child is not this')
        else:
            del self[child.name]
            child.parent = None
            return child

    def keys(self):
        return self._mapping.keys()

    def values(self):
        return self._mapping.values()

    def items(self):
        return self._mapping.items()




class HDFDataNode(HDFTreeNode):
    """
    用来表示 Dataset 的节点。它没有子节点。

    Node used to indicate dataset in HDF5 file. It does not have subnodes.

    attributes:
        name: (str)
        hdf_type: (HDFType) must be one of these:
            HDFType.Data                no extension name
            HDFType.FourDSTEM           4d
            HDFType.Line                line
            HDFType.Image               img
            HDFType.VectorField         vec
    """
    def __init__(self, name: str, parent: HDFGroupNode = None):
        """
        arguments:
            name: (str) the name cannot be null string
            parent: (HDFGroupNode)
        """
        super().__init__(name, parent)
        self._updateTypeByExtension()
        
    @property
    def name(self):
        return self._name

    @name.setter
    def name(self, new_name: str):
        """
        Give a new name to this node. The name here must be a string that:
            - can only include numbers, characters, underline '_', dash '-', 
                dot '.' and space ' '.
            - cannot start as space ' '.
        Otherwise a ValueError is raised.

        As an HDFDataNode, its name cannot be a null string.

        arguments:
            new_name: (str) give a new name to this node. User must change the
                practical item's name in the HDF file at the same time. Otherw-
                ise, after a flush the name change will be lost.
        """
        
        # valid_name_pattern = r'^[0-9a-zA-Z\_\-\.][0-9a-zA-Z\_\-\.\s]*$'
        if not isinstance(new_name, str):
            raise TypeError(('new_name must be a str, not '
                '{0}'.format(type(new_name).__name__)))
        elif new_name == '':
            raise ValueError(
                'HDFDataNode name attribute cannot set as null string'
            )
        elif reValidHDFName.fullmatch(new_name) is None:
            raise ValueError('Invalid name: {0}'.format(new_name))
        elif new_name[-1] == '.':
            raise ValueError('Invalid name: {0}'.format(new_name))
        else:
            self._name = new_name
            self._updateTypeByExtension()

    @property
    def hdf_type(self) -> HDFType:
        return self._hdf_type

    @hdf_type.setter
    def hdf_type(self, new_type: HDFType):
        if not isinstance(new_type, HDFType):
            raise TypeError('new_type must be instance of HDFType')
        Datatypes = [
            HDFType.Data,
            HDFType.FourDSTEM,
            HDFType.Line,
            HDFType.Image,
            HDFType.VectorField,
        ]
        if not new_type in Datatypes:
            raise TypeError(('new_type must be also a kind of data,'
                ' i.e. one of these:\n {0}'.format(Datatypes)))
        self._hdf_type = new_type 

    ext_to_type = {
        '4dstem': HDFType.FourDSTEM,
        'line': HDFType.Line,
        'img': HDFType.Image,
        'vec': HDFType.VectorField,
    }

    type_to_ext = {
            HDFType.Data: '',
            HDFType.Line: 'line',
            HDFType.Image: 'img',
            HDFType.VectorField: 'vec',
            HDFType.FourDSTEM: '4dstem',
        }

    def _updateTypeByExtension(self):
        """
        Update HDF type according to the extension.
        """
        if '.' in self.name:
            ext = self.name.split('.').pop()
            if ext in self.ext_to_type:
                self.hdf_type = self.ext_to_type[ext]
            else:
                self.hdf_type = HDFType.Data
        else:
            self.hdf_type = HDFType.Data


class HDFRootNode(HDFGroupNode):
    """
    用来表示根目录的节点。

    其可以添加、删除子节点，但不能设置名字，也不能设置父节点。

    This node is used to indicate root group in HDF5 file.

    It can add and remove subnode, but neither set name nor set parent.

    attributes:
        name: (str) the name of root is always null string ''

        parent: (NoneType) the parent of root is always None

        hdf_type: (HDFType) must be HDFType.Root
    """
    def __init__(self):
        super().__init__(name = '', parent = None)
        self._hdf_type = HDFType.Root
    
    @property 
    def name(self):
        return ''

    @property 
    def parent(self):
        return None

    @property
    def hdf_type(self) -> HDFType:
        return HDFType.Root 


class HDFTreeModel(QAbstractItemModel):
    """
    用来查看 HDF 文件的路径树结构的 model。

    这是 Qt 中 Model/View 架构的一部分。要显示路径树结构，可以通过实例化 QTreeView，
    然后调用其 setModel() 方法，将这个类的实例传递进去。

    为了实现只读的、显示与数据分离的架构，这个 Model 类必须实现如下方法：
        - columnCount(self, parent: QModelIndex) -> int
            返回相应的 parent 之下有多少列

        - rowCount(self, parent: QModelIndex) -> int
            返回相应的 parent 之下有多少行

        - data(self, index: QModelIndex, role: int)
            根据 role 的不同，返回数据结构中内部存储的数据

        - parent(self, child: QModelIndex) -> QModelIndex
            返回 child 相应的 parent

        - index(self, row: int, column: int, parent: QModelIndex) -> QModelIndex
            根据 parent、行数、列数返回对应的 index。

    注意到，与 HDFTree 不同，这里所有的 child、parent、index 指的并不是 node，而是所
    谓 QModelIndex。这是一种专门用于 model 中的节点。每个节点都有父节点，然后有自己的
    行和列。如果只是表示路径树的话，只需要关注行即可，每行表示一个路径。

    在这些需要我们实现的方法中，有些是要返回正确的 QModelIndex 的。因此创建这些 index
    的方式是调用 self.createIndex(row, column, ptr) 方法。所以，如果想要表示某一个路
    径的 node，我们需要
        - 找到这个 node，作为指针/数据结构的内部数据 ptr。
        - 找到这个 node 在哪一行。由于哈希表是无序的，因此实际上要找的是 node 在某个可
        迭代对象中的序号。
        - 找到这个 node 在哪一列。在这里我们就直接设为第 0 列了。
    然后把上面三个参数填进方法里即可。 

    注意，实践证明，不能使用 HDF5 本身的对象作为 ptr，也不能使用路径字符串作为 ptr。前
    者原因不明，可能与 HDF5 采用的锁机制有关；后者则是因为 python 的垃圾回收机制会将这
    些字符串对象回收掉。所以，唯一方案便是使用 HDFHandler 的路径树。

    进一步地，要实现可修改的 model，则要实现以下方法：
        - insertRow(row: int, parent: QModelIndex) -> bool
            插入一个 item

        - moveRow(
            sourceParent: QModelIndex, 
            sourceRow: int, 
            destinationParent: QModelIndex, 
            destinationChild: int) -> bool
            移动一个 item

        - removeRow(row: int, parent: QModelIndex) -> bool
            删除一个 item

    这些方法本身是没有作用的，因此我们也可以编写自己的 api。但如果要将修改的内容呈现到相
    应的 model 里并及时显示出来，就需要调用
        beginInsertRows(parent: QModelIndex, first: int, last: int)
        ... (insert nodes in data structure)
        endInsertRows()
    这类函数。这些以 begin 和 end 开头的函数会发射信号通知 model 及时根据内部数据结构的
    变化而进行调整，并显示到屏幕上。

    更多关于 Model-View 架构的知识，请见 PySide6 的官方文档：
    https://doc.qt.io/qtforpython/overviews/model-view-programming.html


    This is a model for viewing the hierarchical structure of HDF file.

    This is a part of Model/View architecture of Qt. If we want to display the
    path tree, we can instantiate QTreeView, and call its setModel() method.

    In order to realize a read-only and data-display decoupled architecture, we
    need to reimplement the following methods:
        - columnCount(self, parent: QModelIndex) -> int
            Get number of columns under the parent

        - rowCount(self, parent: QModelIndex) -> int
            Get number of rows under the parent

        - data(self, index: QModelIndex, role: int)
            Return the internal data according to the role

        - parent(self, child: QModelIndex) -> QModelIndex
            Return the parent of child

        - index(self, row: int, column: int, parent: QModelIndex) -> QModelIndex
            Return index according to row, column and parent.

    We note that unlike HDFTree, the child, parent, index here is NOT node of 
    HDFTree, but QModelIndex instance. Every index here has their parent index,
    row and column. Now we only care about path tree, so only row number is ne-
    eded.

    Some of the above methods need to return correct index, so we must create 
    index ourselves. To do this, call self.createIndex(row, column, ptr) method.
    To get the arguments, we need to:
        - find the correspondindg node, as the internal pointer ptr

        - find the rank of the node among its mates. The HDFTree itself doesn't
          has special order, so here we use an iterable of the keysview instead
        
        - find the column of the node. Here we set it to zero.
    Then we put these three arguments into the method and get the index.

    NOTE Practice shows that we can use neither h5py's object nor simple string
    as the internal pointer of the index. The reason may be relate to the garb-
    age collecting mechanic of python and Qt. Hence, that's why we have to make
    HDFTree ourselves.

    Further more, if we want a writable model, we need to reimplement the foll-
    owing methods:
        - insertRow(row: int, parent: QModelIndex) -> bool
            insert an item

        - moveRow(
            sourceParent: QModelIndex, 
            sourceRow: int, 
            destinationParent: QModelIndex, 
            destinationChild: int,
        ) -> bool
            move an item

        - removeRow(row: int, parent: QModelIndex) -> bool
            delete an item

    However, these methods themselves do not work. So we can write our own APIs.
    But if we want to modify the model by write internal data, we shall call

        beginInsertRows(parent: QModelIndex, first: int, last: int)
        ... (insert nodes in data structure)
        endInsertRows()
    
    These functions that begin with 'begin' and 'end' will emit signals to note
    the model and the related views change themselves in time. 

    About Model/View architecture, see documents of PySide6:
    https://doc.qt.io/qtforpython/overviews/model-view-programming.html
    """

    DataRoles = ItemDataRoles

    def __init__(self, hdf_handler: HDFHandler):
        """
        arguments
            hdf_handler: (HDFHandler) to get the HDFTree and the practical file
        """
        super().__init__()
        self._hdf_handler = hdf_handler
        
    
    @property
    def logger(self) -> Logger:
        global qApp
        return qApp.logger

    @property 
    def hdf_handler(self):
        return self._hdf_handler

    @property 
    def theme_handler(self):
        global qApp 
        return qApp.theme_handler

    def index(self, 
        row: int, 
        column: int, 
        parent: QModelIndex,
    ) -> QModelIndex:
        """
        Get the index from row, column, and parent.

        arguments:
            row: (int)
            column: (column)
            parent: (QModelIndex)
        
        returns:
            (QModelIndex)
        """
        if not parent.isValid():
            return self.createIndex(0, column, self.hdf_handler.root_node)
        else:
            parent_node = parent.internalPointer()
            key_list = list(parent_node.keys())
            if row < len(parent_node):
                node = parent_node[key_list[row]]
                return self.createIndex(row, column, node)
            else:
                return QModelIndex()

    def parent(self, child: QModelIndex) -> QModelIndex:
        """
        Get the parent index of child index.

        arguments:
            child: (QModelIndex)
        
        returns:
            (QModelIndex)
        """
        if not child.isValid():
            return QModelIndex()
        elif child.internalPointer() is self.hdf_handler.root_node:
            return QModelIndex()
        else:
            parent_node = child.internalPointer().parent
            row = self.hdf_handler.getRank(parent_node.path)
            return self.createIndex(row, 0, parent_node)

    def rowCount(self, parent: QModelIndex) -> int:
        """
        Get the number of rows under the parent.

        arguments:
            parent: (QModelIndex)
        """
        if not parent.isValid():
            return 1    # only one member: root
        else:
            parent_node = parent.internalPointer()
            return len(parent_node)

    def columnCount(self, parent: QModelIndex) -> int:
        """
        Get the number of columns under the parent.

        arguments:
            parent: (QModelIndex)
        """
        return 1

    item_icons = {
        HDFType.Root: 'database',
        HDFType.Data: 'file',
        HDFType.Group: 'folder',
        HDFType.Image: 'picture',
        HDFType.Line: 'line',
        HDFType.VectorField: 'particle_tracking',
        HDFType.FourDSTEM: 'cube',
        HDFType.Item: 'file',
        HDFType.String: 'file',
        HDFType.Reference: 'share',
    }

    def data(self, index: QModelIndex, role: int):
        """
        Get the practical data from the internal data structure.

        The argument role are defined in Qt module from PySide6.QtCore. Here we
        use Constants.ItemDataRoles instances.

        arguments:
            index: (QModelIndex)
            role: (int)
        """
        if not index.isValid():
            return None
        node: HDFTreeNode = index.internalPointer()
        if role == self.DataRoles.NodeRole:
            return node

        elif role == self.DataRoles.PathRole:
            return node.path

        elif role == self.DataRoles.DisplayRole:    # same as Qt.DisplayRole
            if isinstance(node, HDFRootNode):
                if self.hdf_handler.isFileOpened():
                    return os.path.split(self.hdf_handler.file_path)[1]
                else:
                    return 'CREATE/OPEN A FILE'
            else:
                return node.name

        elif role == self.DataRoles.ToolTipRole:    # same as Qt.ToolTipRole
            if node.hdf_type == HDFType.Root:
                return '<Root> {0} members'.format(len(node))
            elif node.hdf_type == HDFType.Group:
                return '<Group> {0} members'.format(len(node))
            elif node.hdf_type in (
                HDFType.Line, 
                HDFType.Image, 
                HDFType.VectorField, 
                HDFType.FourDSTEM, 
                HDFType.Data,
            ):
                type_str = '{0}'.format(node.hdf_type.name)
                return '<{0}> shape: {1}, dtype: {2}'.format(
                    type_str,
                    self.hdf_handler.file[node.path].shape,
                    self.hdf_handler.file[node.path].dtype,
                )

        elif role == self.DataRoles.HDFTypeRole:
            return node.hdf_type
        elif role == self.DataRoles.DecorationRole:
            if self.hdf_handler.isFileOpened():
                _path = ':/HDFItem/resources/icons/'
                icon_name = self.item_icons[node.hdf_type]
                return self.theme_handler.iconProvider(_path + icon_name)
            
        else:
            return None

    def headerData(self, 
        section: int, 
        orientation: Qt.Orientation = Qt.Horizontal, 
        role: int = Qt.DisplayRole,
    ):
        """
        Get the data for the header.

        arguments:
            section: (int) the section (index) of the header.

            orientation: (Qt.Orientation) Qt.Vertical or Qt.Horizontal

            role: (int)
        """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            return None

    def indexFromPath(self, hdf_path: str) -> QModelIndex:
        """
        Get the model index from the path.

        arguments:
            hdf_path: (str) 

        returns:
            (QModelIndex) If the path is not valid, this function will return 
                QModelIndex()
        """
        try:
            node = self.hdf_handler.getNode(hdf_path)
            row = self.hdf_handler.getRank(hdf_path)
            return self.createIndex(row, 0, node)
        except KeyError:
            return QModelIndex()
        


    def insertGroup(self, parent: QModelIndex, name: str):
        """
        Insert a group in the parent index.

        arguments:
            parent: (QModelIndex)
            name: (str) the name of the new group
        """
        if not parent.isValid():
            raise ValueError('Cannot insert group in invalid parent index.')

        self.hdf_handler.addNewGroup(
            parent.data(role = self.DataRoles.PathRole),
            name,
        )

        

    def insertData(self, 
        parent: QModelIndex, 
        name: str,
        shape: tuple,
        dtype: str = 'float32',
        compression: str|int = 'gzip'):
        """
        Insert a data in the parent index.

        arguments:
            parent: (QModelIndex)
            name: (str) the name of the new dataset
            shape: (tuple) must be tuple of integers
            dtype: (str) 'float32' ...
            compression: (str) default uses 'gzip', (int) default uses 4. See 
                h5py documents for more information.
        """
        if not parent.isValid():
            raise ValueError('Cannot insert data in invalid parent index.')
        # row = self.rowCount(parent)
        # self.beginInsertRows(parent, row, row)
        self.hdf_handler.addNewData(
            parent.data(role = self.DataRoles.PathRole),
            name = name,
            shape = shape,
            dtype = dtype,
            compression = compression,
        )
        # self.endInsertRows()

    def removeItem(self, child: QModelIndex):
        """
        Delete an item in the parent index.

        arguments:
            child: (QModelIndex) 
        """
        if not child.isValid():
            raise ValueError('Cannot remove invalid index')
        child_path = child.data(role = self.DataRoles.PathRole)
        # row = self.hdf_handler.getRank(child_path)
        # self.beginRemoveRows(child.parent(), row, row)
        self.hdf_handler.deleteItem(child_path)
        # self.endRemoveRows()

    def moveItem(self, child: QModelIndex, dest_parent: QModelIndex):
        """
        Move the item from child to dest_parent.

        arguments:
            child: (QModelIndex) the index that to be moved

            dest_parent: (QModelIndex) the destination parent index
        """
        if not child.isValid():
            raise ValueError('Cannot move invalid child')
        if not dest_parent.isValid():
            raise ValueError('Cannot move items to invalid destination')
        child_path = child.data(role = self.DataRoles.PathRole)
        # row = self.hdf_handler.getRank(child_path)
        # self.beginMoveRows(
        #     child.parent(),
        #     row,
        #     row,
        #     dest_parent,
        #     self.rowCount(dest_parent),
        # )
        self.hdf_handler.moveItem(
            child_path, 
            dest_parent.data(role = self.DataRoles.PathRole)
        )
        # self.endMoveRows()

    def renameItem(self, child: QModelIndex, name: str):
        """
        Rename the item.

        arguments:
            child: (QModelIndex) the index that to be renamed

            name: (str) the new name
        """
        if not child.isValid():
            raise ValueError('Cannot rename invalid item')

        child_path = child.data(role = self.DataRoles.PathRole)
        self.hdf_handler.renameItem(child_path, name)



    def copyItem(self, child: QModelIndex, dest_parent: QModelIndex):
        """
        Copy the item to destination.

        arguments:
            child: (QModelIndex) the index that to be copied

            dest_parent: (QModelIndex) the destination parent index
        """
        if not child.isValid():
            raise ValueError('Cannot copy invalid item')
        elif not dest_parent.isValid():
            raise ValueError('Cannot copy to an invalid item')

        child_path = child.data(role = self.DataRoles.PathRole)
        dest_parent_path = dest_parent.data(role = self.DataRoles.PathRole)
        
        # Because copying is an asynchronous task, so here we do not update
        # model. When the task do preparation and following work, the model
        # is updated.
        self.hdf_handler.copyItem(child_path, dest_parent_path)


    def changeItemType(self, child: QModelIndex, new_type: HDFType):
        """
        Change the hdf_type of the internal node of the index.

        arguments:
            child: (QModelIndex) the index to be changed

            new_type: (HDFType) 
        """
        if not child.isValid():
            raise ValueError('Cannot change the type of invalid item')
        child_path = child.data(role = self.DataRoles.PathRole)
        self.hdf_handler.changeDataType(child_path, new_type)
        self.dataChanged.emit(child, child)

    def matchIndexGenerator(self, kw: str):
        """
        A generator that yields the indexes matching the keywords.

        arguments:
            kw: (str)

        returns:
            (generator) generates QModelIndex
        """
        for node in self.hdf_handler.matchNodeGenerator(kw):
            yield self.indexFromPath(node.path)


class TaskCopy(Task):
    """
    复制任务，将 HDF5 对象及其所有子对象都复制过去。

    这个任务会提交到线程池运行。更多有关信息请查看 TaskManager 模块。       

    Copy an item with all its children to destination.

    For more information of Task object, see TaskManager module.
    """
    def __init__(self,
        parent: QObject, 
        item_path: str, 
        dest_parent_path: str, 
        new_name: str
    ):
        super().__init__(parent)
        self._item_path = item_path
        self._dest_parent_path = dest_parent_path
        self._new_name = new_name


        self.name = 'copy'
        self.comment = (
            'Copy item from: {0}\n'
            'Destination:{1}\n'
            'New name: {2}'.format(
                item_path, dest_parent_path, new_name
            )
        )

        if dest_parent_path == '/':
            new_path = '/' + new_name
        else:
            new_path = dest_parent_path + '/' + new_name
        
        self.addSubtaskFunc(
            'Copy Items',
            self.hdf_handler.file.copy,
            item_path,
            new_path,
        )

        self.setPrepare(self._copyPrepare)
        self.setFollow(self._copyFollow)

    @property 
    def task_manager(self) -> TaskManager:
        global qApp 
        return qApp.task_manager

    @property
    def model(self) -> HDFTreeModel:
        return self.hdf_handler.model

    @property
    def hdf_handler(self) -> HDFHandler:
        global qApp 
        return qApp.hdf_handler

    def _copyPrepare(self):
        """
        Preparation work of copy. Create one node in the destination.
        """
        item_path = self._item_path
        dest_parent_path = self._dest_parent_path
        new_name = self._new_name

        old_node = self.hdf_handler.getNode(item_path)
        dest_parent_node = self.hdf_handler.getNode(dest_parent_path)
        if isinstance(old_node, HDFGroupNode):
            new_node = HDFGroupNode(new_name)
        elif isinstance(old_node, HDFDataNode):
            new_node = HDFDataNode(new_name)

        dest_parent_index = self.model.indexFromPath(dest_parent_path)
        row = self.model.rowCount(dest_parent_index)
        # print('Prepare called')
        self.model.beginInsertRows(dest_parent_index, row, row)
        dest_parent_node.addChild(new_node)
        self.model.endInsertRows()

    def _copyFollow(self):
        """
        Following work of copy. Create child nodes recursively.
        """
        dest_parent_path = self._dest_parent_path
        new_name = self._new_name
        dest_parent_node = self.hdf_handler.getNode(dest_parent_path)
        new_node = dest_parent_node[new_name]
        if isinstance(new_node, HDFGroupNode):
            new_node = self.hdf_handler.addChildDeepFirst(new_node)
        new_index = self.model.indexFromPath(new_node.path)
        self.model.dataChanged.emit(new_index, new_index)
        # print('Follow called')

    def addToTaskManager(self):
        self.task_manager.addTask(self)


class HDFAttrModel(QAbstractTableModel):
    """
    用于显示 HDF5 对象的属性的 Model。

    HDF5 对象的属性是一个类似于 Mapping 的数据结构，而该表格有两列，左列就是 key，右
    列就是 Value。

    这是 Qt 中 Model/View 架构的一部分。要显示等待队列，通过实例化 QListView，然后
    调用其 setModel() 方法，把这个类的实例传递进去。

    为了实现只读的、显示与数据分离的架构，这个 Model 类必须实现如下方法：
        - rowCount(self, parent: QModelIndex) -> int
            返回相应的 parent 之下有多少行

        - data(self, index: QModelIndex, role: int)
            根据 role 的不同，返回数据结构中内部存储的数据

    注意，实践证明，不能使用 HDF5 本身的对象作为 ptr，原因不明，可能与 HDF5 采用的锁
    机制有关；所以，唯一方案便是自己创建一个 meta 副本，而只在修改时访问 HDF5 文件。

    This is a model for viewing attributions of HDF5 objects.

    Attributions of HDF5 objects are like Mapping (dict in python), So we use
    a table to show them. There are 2 columns in the table, the left contains
    keys, while the right contains values.

    This is a part of Model/View architecture of Qt. If we want to display the
    path tree, we can instantiate QTreeView, and call its setModel() method.

    In order to realize a read-only and data-display decoupled architecture, we
    need to reimplement the following methods:
        - rowCount(self, parent: QModelIndex) -> int
            Get number of rows under the parent

        - data(self, index: QModelIndex, role: int)
            Return the internal data according to the role

    NOTE: Practice shows that it seems we cannot use h5py.AttributeManager 
    itself as the ptr, and I don't know why. So here we create a replica: meta
    as a dict, which will always conserves the same as the attrs. Only when we
    need to modify the attribution, we use attrs.

    attributes:
        hdf_handler: (HDFHandler)

        item_path: (str) the corresponding h5py object's path

        attrs: (h5py.AttributeManager) the AttributeManager of the h5py object

        meta: (dict) replica. always conserves the same as self.attrs
    """
    def __init__(self, parent: QObject = None):
        super().__init__(parent)
        self._item_path = '/'
        self._meta = {}
        

    @property
    def hdf_handler(self) -> HDFHandler:
        global qApp 
        return qApp.hdf_handler

    @property
    def item_path(self) -> str:
        return self._item_path

    @item_path.setter
    def item_path(self, path: str):
        self.hdf_handler.getNode(path)
        self._item_path = path 

    @property
    def meta(self):
        return self._meta

    @property
    def attrs(self) -> h5py.AttributeManager:
        return self.hdf_handler.file[self.item_path].attrs

    @property
    def logger(self) -> Logger:
        global qApp
        return qApp.logger


    def initialize(self, item_path: str):
        self.item_path = item_path
        self.beginRemoveRows(QModelIndex(), 0, self.rowCount())
        self._meta = {}
        self.endRemoveRows()
        self.beginInsertRows(QModelIndex(), 0, len(self.attrs))
        for key in self.attrs:
            self.meta[key] = self.attrs[key]
        self.endInsertRows()

    def columnCount(self, parent: QModelIndex = QModelIndex()) -> int:
        """
        The number of columns.

        arguments:
            parent: (QModelIndex)

        returns:
            (int) 2. left is key, right is value.
        """
        return 2

    def rowCount(self, parent: QModelIndex = QModelIndex()) -> int:
        """
        The number of rows.
        """
        return len(self.meta)

    def data(self, index: QModelIndex, role: int):
        """
        The data of the attributions.

        arguments:
            index: (QModelIndex)

            role: int (ItemDataRoles)
        """
        if not index.isValid():
            return None
        row = index.row()
        column = index.column()
        key = list(self.meta.keys())[row]
        value = self.meta[key]
        if role == Qt.DisplayRole:
            if column == 0:
                return '{0}'.format(key)
            elif column == 1:
                if isinstance(value, np.ndarray):
                    if len(value) > 5:
                        return ('<numpy.ndarray> shape: '
                                '{0}'.format(value.shape))
                return '{0}'.format(value)
            else:
                return None
        elif role == Qt.ToolTipRole:
            if isinstance(value, np.ndarray):
                return '<numpy.ndarray> shape: {0}'.format(value.shape)
            else:
                return f'<{type(value).__name__}: {self.data(index, Qt.DisplayRole)}>'
        else:
            return None
            
    def headerData(
        self, 
        section: int, 
        orientation: Qt.Orientation = Qt.Horizontal, 
        role: int = Qt.DisplayRole
    ):
        """
        Write the header data of the table.

        arguments:
            section: (int)

            orientation: (Qt.Orientation)

            role: (int)

        returns:
            (str) 'KEY' or 'VALUE' or ''.
        """
        if role == Qt.DisplayRole and orientation == Qt.Horizontal:
            if section == 0:
                return 'KEY'
            elif section == 1:
                return 'VALUE'
        return None

    def indexFromKey(self, key: str) -> QModelIndex:
        """
        Get the index from a key.

        arguments:
            key: (str)

        returns:
            (QModelIndex) must be the index of column 0.
        """
        if not isinstance(key, str):
            raise TypeError('key must be a str, not '
                '{0}'.format(type(key).__name__))
        if not key in self.meta:
            raise KeyError('Key not founded.')
        
        row = list(self.meta.keys()).index(key)
        column = 0
        return self.createIndex(row, column)

    def keyFromIndex(self, index: QModelIndex) -> str:
        """
        Get the key from the index.

        arguments:
            index: (QModelIndex)

        returns:
            (str) the key of the corresponding index, regardless the column.
        """
        row = index.row()
        return list(self.meta.keys())[row]

    def createItem(self, key: str, value):
        """
        Add an item.
        
        arguments:
            key: (str)

            value: Any (str, int, float, np.ndarray)
        """
        if not isinstance(key, str):
            raise TypeError('key must be a str, not '
                '{0}'.format(type(key).__name__))
        if key in self.meta:
            raise ValueError('key already exists.')

        self.beginInsertRows(
            QModelIndex(), 
            self.rowCount(), 
            self.rowCount(),
        )
        
        self.attrs.create(key, value)
        self.meta[key] = value
        self.endInsertRows()
        self.logger.debug('Create Attribute {0} in {1}'.format(
            key, self.item_path))

    def deleteItem(self, index: QModelIndex):
        """
        Delete an item according to the index.

        arguments:
            index: (QModelIndex)
        """
        if not isinstance(index, QModelIndex):
            raise TypeError('index must be QModelIndex, not '
                '{0}'.format(type(index).__name__))
        if not index.isValid():
            return None
        key = self.keyFromIndex(index)
        row = index.row()
        self.beginRemoveRows(QModelIndex(), row, row)
        del self.attrs[key]
        del self.meta[key]
        self.endRemoveRows()
        self.logger.debug('Delete Attribute {0} in {1}'.format(
            key, self.item_path
        ))

    def modifyValue(self, index: QModelIndex, value):
        """
        Modify an item. The type should not be changed.

        arguments:
            index: (QModelIndex)

            value: Any (must conserve the type of the original item)
        """
        if not isinstance(index, QModelIndex):
            raise TypeError('index must be QModelIndex, not '
                '{0}'.format(type(index).__name__))
        if not index.isValid():
            return None
        key = self.keyFromIndex(index)
        self.attrs.modify(key, value)
        self.meta[key] = value
        self.dataChanged().emit(QModelIndex(), index)
        self.logger.debug('Change the value of attribute {0} in {1}'.format(
            key, self.item_path
        ))
    





    


